commonfields:
  id: 0b39d0d8-2c04-4a9c-8def-c7a0ccbe585d
  version: 37
vcShouldKeepItemLegacyProdMachine: false
name: DSPMExtractRiskDetails
script: |+
  from typing import Dict, Any
  import traceback
  import json
  from datetime import datetime

  def get_config_data():
    result = demisto.executeCommand("dspm-get-integration-config", {})
    integration_conf = result[0].get("Contents", {}).get("integration_config", {})
    return integration_conf


  def set_user_slack_email(assetDigTags):
      integration_conf = get_config_data()
      # Extract the email from the 'Owner' field
      email = None
      if 'Owner' in assetDigTags and isinstance(assetDigTags['Owner'], list) and assetDigTags['Owner']:
          email = assetDigTags['Owner'][0]

      # If email is not found, set it to the default value "jira"
      if not email:
          email = integration_conf.get('defaultSlackUser')

      # Set the value in XSOAR context
      demisto.setContext("userSlackEmail", email)


  def get_incident_details_command(args):
      incident_data = args.get("incident_object", {})
      # Get assetdigtags, ensure it's a dictionary; if not, parse it or assign an empty dictionary
      assetDigTags = incident_data.get('assetdigtags', '{}')
      if isinstance(assetDigTags, str) and assetDigTags.strip():  # Check if it's a non-empty string
          try:
              assetDigTags = json.loads(assetDigTags)
          except json.JSONDecodeError:
              demisto.error(f"Failed to parse assetDigTags: {assetDigTags}")
              assetDigTags = {}
      elif not isinstance(assetDigTags, dict):
          assetDigTags = {}
      incident_object = {
          "incidentId": incident_data.get('id', 'N/A'),
          "riskFindingId": incident_data.get('riskfindingid', 'N/A'),
          "ruleName": incident_data.get('riskname', 'N/A'),
          "severity": incident_data.get('severity', 'N/A'),
          "assetName": incident_data.get('assetname', 'N/A'),
          "assetId": incident_data.get('assetid', 'N/A'),
          "Status": incident_data.get('status', 'N/A'),
          "projectId": incident_data.get('projectid', 'N/A'),
          "cloudProvider": incident_data.get('cloud', 'N/A'),
          "serviceType": incident_data.get('serviceType', 'N/A'),
          "firstDetectedOn": incident_data.get('firstdetectedon', 'N/A'),
          "asset Dig Tags": json.dumps(assetDigTags),  # Ensure it's always a string representation
          "remediateInstruction": incident_data.get('remediateinstruction', 'N/A'),
          "incidentCreated": datetime.strftime(datetime.now(), "%Y-%m-%d %H:%M:%S.%f")
      }
      set_user_slack_email(assetDigTags)
      return incident_object


  ''' MAIN FUNCTION '''

  def main():

      try:
          incident_object = demisto.args().get('incident_object')
          incident_id = incident_object.get('id')
          incident_details = get_incident_details_command(demisto.args())
          return_results(
                CommandResults(
                    readable_output=tableToMarkdown("Incident Details : ", incident_details, removeNull=True),
                    outputs_prefix="incident_object",
                    outputs=incident_details
                )
              )
      except Exception as e:
          demisto.error(f"Error building incident object: {str(e)}")
          demisto.setContext("OnError.Message", f"Error while extracting risk details for incident {incident_id}: {str(e)}")
          return_error(f"Error building incident object: {str(e)}")


  ''' ENTRY POINT '''


  if __name__ in ('__main__', '__builtin__', 'builtins'):
      main()

type: python
tags: []
enabled: true
args:
- name: incident_object
  required: true
outputs:
- contextPath: incident_object
- contextPath: userSlackEmail
scripttarget: 0
subtype: python3
pswd: ""
runonce: false
dockerimage: demisto/python3:3.11.9.107902
runas: DBotWeakRole
engineinfo: {}
mainengineinfo: {}
